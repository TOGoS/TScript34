#+TITLE: TScript34 P0019

** Status

As of v0.2.6 (2024-08-29) the more fleshed-out
part of this project is some commands for building Java projects,
with syntax and architecture similar to JCR36.

The script interpreter is not yet very useful.

** Use for remote Javacing

One thing you can do with this tool is use it to build
Java projects on a remote server, using the
~ts34p19:unzip-to-temp-and-run~ and
~ts34p19:compile-jar~ sub-commands:

#+BEGIN_SRC
java -jar TS34P19-v0.2.6.jar ts34p19:compile-jar --resources=src\main\java -o - \
	| plink me@my-build-server java -jar ~/bin/TS34P19-v0.2.6.jar \
		ts34p19:unzip-to-temp-and-run - \
			ts34p19:compile-jar \
				--java-sources=. \
				--main-class=net.nuke24.tscript34.p0019.cmd.P0019Command \
				-o - \
>remotely-built.jar
#+END_SRC

You need to already have TS34P19-v0.2.6.jar on the local
and remote servers for that to work.

A simpler example, running locally but entirely via stdin/stdout:

#+BEGIN_SRC
java -jar TScript34-P0019/TS34P19-v0.2.6.jar \
	ts34p19:unzip-to-temp-and-run - \
		ts34p19:compile-jar \
			--java-sources=. \
			--main-class=net.nuke24.tscript34.p0019.cmd.P0019Command \
			-o - \
<sources.zip >compiled.zip
#+END_SRC

** Original Goal

An embeddable, general-purpose TS34 interpreter,
possibly with support for alternate, PostScript-like syntax.

Intended primary use cases:
- Horsing with RDF structures, especially TOGVM expressions
- Serve as a protocol for scripting and communication between
  random programs like ContentCouch that seem to
  "want to have a simple scripting language"

The VM design seems a good one, as it allows side-effects
to be handled orthogonally to interpretation.
I want the core interpreter logic to be 100% pure functional.

The 'single-class' concept has been proved well enough;
I can back down on that.  Though it may still be wise
to choose fewer instad of more classes.  I haven't quite
figured out how to balance my approach.  Java makes it difficult, I think.

** Package layout

- net.nuke24.tscript34.p0019 :: root package for this project
- net.nuke24.tscript34.p0019.iface :: generic interface definitions, candidates for moving to p0010
- net.nuke24.tscript34.p0019.value :: 'value' classes, which may have special meaning to the interpreter

** Origins

See WSITEM-3408 p155.

Based on P0009, which was in turn based on P0006.
"This one I can pollute."

First step was to split P0006 and P0009 subtrees,
so that this could be a nice self-contained tree,
which is what I decided is the way to go for new
sub-projects.

Git commits:

| original p0009-master                   | 248d236ebf20600249d7a26125aa0eaeeeb09480 |
| subtrees/p0006/split-from-master        | 891e25d0bc32d6558a5026c1e6a6dac969c93f8a |
| subtrees/p0009/split+rebased-onto-p0006 | 62c68e7c1422a849bb54b09c2fdba76bc042d038 |

** Schema

*** http://ns.nuke24.net/TScript34/P0019/Ops/Javac

(sourcedir:Directory cp:List[Directory|JAR] sourceVersion:JDKVersion targetVersion:JDKVersion -- Directory)

Given a directory (any recognizable representation of one),
a list of directories and/or JAR files to include on the classpath,
and source and target version numbers (e.g. "1.6"),
invokes ~javac~ to produce a directory full of ~.class~ files.

Presumably directory <-> JAR conversion can be done with datatypes,
so does not need explicit ops.

This may be useful in situations where it would be undesireable
to allow arbitrary processess to be constructed.
Otherwise, I think it would be more sensible to define
lower-level process control ops, and just use those.

Of course, nobody's stopping an implementation from defining
Javac in terms of a sequence of lower-level process control ops!

** Log / thoughts

*** 2024-05-30

Having just refactored so that the 'return with value' effect within
a stack-based program returns the entire stack, which is 'passed to'
continuations, I think has given me an idea about...monoidification.

i.e. how to make ~instruction1.then(instruction2).then(instruction3)~ work.

Each instruction is a function of stack -> stack.

Most instructions have a null ~next~ pointer, meaning they don't care where you go next.
~.then~ replaces null ~next~ pointers.
But if an instruction already has a ~next~ pointer, meaning it jumps out of the
normal control flow, then ~.then~ has no effect on it!

As the current implementation shows, this doesn't need to be
implemented by looking inside the instructions.
If instructions return their next pointer,
then ~.then~ can be implemented by simply adding instructions to a list
which is by default executed in order by the interpreter, until
some instruction returns non-null.

I'm not 100% convinced this works correctly, but if it does,
I think it solves the "need to know the next step before calling instruction constructors"
problem that I ran into with TScript34-P0013,
which lacked representation of continuation-agnostic steps,
but may have otherwise been on the right track.

*** 2024-06-10

I'm working on a ~JavaProjectBuilder~ class whose purpose shall be to
help build Java 1.6-compatible JARs of this project,
which will also be usable by others.

It is not obvious that this needs to be part of TScript34-P0019,
but since the purpose of both the scripting language and the Java package
builder is to help solve 'the bootstrapping problem'
(i.e. cross-platform scripting language for automating parts of the build
that the JDK, or older versions of it at least, doesn't do,
which might otherwise be solved by Maven),
it kind of makes sense to shove them in together, at least for now.
Theoretically this will obsolete TJBuilder, and perhaps also TJFetcher,
since the language should have built-in support for hash URNs, anyway.

*** 2024-06-14

Thinking on borrowing "#CHUNK" from SGTA in order
to include big chunks of data in the stream
without having to encode them as ~data~ URIs.

#+begin_src
#CHUNK <size in bytes> <command or something?>
<size bytes of data>
<optional whitespace, newline>
#ENDCHUNK [--crc32=<crc>]
#+end_src

For 'command or something', how about ~--id=urn:bitprint:ABC.123~?

This would cause the interpreter to:
- Verify the hash, if the ID is recognized as a hash URN
- Ensure that ~urn:bitprint:ABC.123~ is available
  for the duration of the rest of the script,
  e.g. for use by ~PushValue~.

By default, this would only store the blob
in a scope local to the script.
~--sector=foosector~ could be specified to indicate
that the data should be stored longer-term
in the interpreter's repository.
- On the one hand this is sort of multiple-responsibilifying.
- On the other hand, I suppose it's simpler for the interpreter
  to split up a compound operation than it is to
  optimize two operations that could have been one.
- Common case really will be to store that data to a repository.

There should be an equivalent regular op for this.
I haven't decided what it should look like.
May want to support ~--foo-option=...~ syntax
for TS34 ops idk.

*** 2024-06-15

On use as a build automation tool.

- Process management
  - Spawn, wait for system processes
  - Create pipelines, serial processes
  - Ability to handle exit codes in different ways
  - Reactive process-like actors
  - Monadic construction of all the above,
    independent of execution strategy

- Temporary contexts
  - Within which, create temporary files, execute some processes, wait...
  - All resources automatically closed when finished
