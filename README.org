#+TITLE: TScript34 P0019

** Goal

An embeddable, general-purpose TS34 interpreter,
possibly with support for alternate, PostScript-like syntax.

Intended primary use cases:
- Horsing with RDF structures, especially TOGVM expressions
- Serve as a protocol for scripting and communication between
  random programs like ContentCouch that seem to
  "want to have a simple scripting language"

The VM design seems a good one, as it allows side-effects
to be handled orthogonally to interpretation.
I want the core interpreter logic to be 100% pure functional.

The 'single-class' concept has been proved well enough;
I can back down on that.  Though it may still be wise
to choose fewer instad of more classes.  I haven't quite
figured out how to balance my approach.  Java makes it difficult, I think.

** Package layout

- net.nuke24.tscript34.p0019 :: root package for this project
- net.nuke24.tscript34.p0019.iface :: generic interface definitions, candidates for moving to p0010
- net.nuke24.tscript34.p0019.value :: 'value' classes, which may have special meaning to the interpreter

** Origins

See WSITEM-3408 p155.

Based on P0009, which was in turn based on P0006.
"This one I can pollute."

First step was to split P0006 and P0009 subtrees,
so that this could be a nice self-contained tree,
which is what I decided is the way to go for new
sub-projects.

Git commits:

| original p0009-master                   | 248d236ebf20600249d7a26125aa0eaeeeb09480 |
| subtrees/p0006/split-from-master        | 891e25d0bc32d6558a5026c1e6a6dac969c93f8a |
| subtrees/p0009/split+rebased-onto-p0006 | 62c68e7c1422a849bb54b09c2fdba76bc042d038 |

** Log / thoughts

*** 2024-05-30

Having just refactored so that the 'return with value' effect within
a stack-based program returns the entire stack, which is 'passed to'
continuations, I think has given me an idea about...monoidification.

i.e. how to make ~instruction1.then(instruction2).then(instruction3)~ work.

Each instruction is a function of stack -> stack.

Most instructions have a null ~next~ pointer, meaning they don't care where you go next.
~.then~ replaces null ~next~ pointers.
But if an instruction already has a ~next~ pointer, meaning it jumps out of the
normal control flow, then ~.then~ has no effect on it!

As the current implementation shows, this doesn't need to be
implemented by looking inside the instructions.
If instructions return their next pointer,
then ~.then~ can be implemented by simply adding instructions to a list
which is by default executed in order by the interpreter, until
some instruction returns non-null.

I'm not 100% convinced this works correctly, but if it does,
I think it solves the "need to know the next step before calling instruction constructors"
problem that I ran into with TScript34-P0013,
which lacked representation of continuation-agnostic steps,
but may have otherwise been on the right track.
